---
title: "Анализ заболеваемости Covid19"
author: "Юрченков Иван Алескандрович ИММО-01-20"
output: 
  word_document: 
    highlight: haddock
    fig_width: 8
    fig_height: 8
    fig_caption: yes
    keep_md: yes
    toc: yes
---

```{r setup, echo = FALSE, include = FALSE}
# Загрузка всех данных и импорт данных в проект и библиотеки ------------------

libraries = c("tidyverse", "openxlsx",
              "dplyr", "tidyr", "stringr",
              "ggplot2", "forecast",
              "openxlsx", "quantreg", "deSolve")

#' Downloading and installing packages in R session
#'
#' @param libs - vector of character libraries that you want to download
#'
#' @return NULL
#' @export
#'
#' @examples
#' install_new_package("ggplot2")
#' install_new_package(c("dplyr", "forecast"))
install_new_package <- function(libs = libraries) {
    for (libI in libs) {
        if (libI %in% installed.packages() == FALSE) {
            install.packages(libI)
        }
    }
}

install_new_package(libs = libraries)

if (!dir.exists("./output_pngs/")) {
  dir.create("./output_pngs")
}


if (!dir.exists("./output_pngs/World")) {
  dir.create("./output_pngs/World")
}
# Подключение пакетов -----------------------------------------------------
library(dplyr)    # Обработка фреймов
library(tidyr)    # Пакет для приведения данных в порядок
library(stringr)  # Пакет для обработки строк
library(openxlsx) # Пакет для экспорта данных в xlsx
library(deSolve)

# Загрузка данных ---------------------------------------------------------
df <- read.csv(file = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv")
cat("\nConfid data downloaded!\n")
df_deaths <- read.csv(file = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv")
cat("\nDeaths data downloaded\n")
df_recovered <- read.csv(file = "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv")
cat("\nRecovered data downloaded\n")
# Исследование данных -----------------------------------------------------

# Имена столбцов показывают, что данные о Covid19 обновляются путём добавления
# столбцов каждый день
#
# Строк 273, что соответствует локациям, в которых проводятся подсчёты
# статистики числа заболевших
#
# О странах известно, в каких точных (до второго знака)
# координатах они находятся
#
# Типы полей - целочисленные


# Слияние колонок страна/регион -------------------------------------------

# Создадим новую колонку из двух старых
df <- tidyr::unite(data = df,
                   col = "Country/Province",
                   sep = "/",
                   Country.Region,
                   Province.State)
df_deaths <- tidyr::unite(data = df_deaths,
                          col = "Country/Province",
                          sep = "/",
                          Country.Region,
                          Province.State)
df_recovered <- tidyr::unite(data = df_recovered,
                             col = "Country/Province",
                             sep = "/",
                             Country.Region,
                             Province.State)

# Создание дополнительного фрейма данных с метаданными о странах ----------

#“Страна/Регион”
#Широта
#Долгота
#Сумма заболевших
#Среднее число заболевших
#Стандартное отклонение числа заболевших

# Сохраним названия в отдельный вектор
country_names <- df$`Country/Province`
country_names_deaths <- df_deaths$`Country/Province`
country_names_recovered <- df_recovered$`Country/Province`

# Сохраним даты в отдельный вектор
test_dates <- colnames(df)[4:ncol(df)]

# Сохраним в отдельный df информацию о странах и описательные статистики
df_meta <- data.frame(df[, 1:3],
                      pos_mean = apply(as.matrix(df[, 4:ncol(df)]), 1, mean),
                      pos_std = apply(as.matrix(df[, 4:ncol(df)]), 1, mean),
                      pos_sum = apply(as.matrix(df[, 4:ncol(df)]), 1, sum))
df_deaths_meta <- data.frame(df_deaths[, 1:3],
                             pos_mean = apply(as.matrix(df[, 4:ncol(df)]), 1, mean),
                             pos_std = apply(as.matrix(df[, 4:ncol(df)]), 1, mean),
                             pos_sum = apply(as.matrix(df[, 4:ncol(df)]), 1, sum))
df_recovered_meta <- data.frame(df[, 1:3],
                                pos_mean = apply(as.matrix(df[, 4:ncol(df)]), 1, mean),
                                pos_std = apply(as.matrix(df[, 4:ncol(df)]), 1, mean),
                                pos_sum = apply(as.matrix(df[, 4:ncol(df)]), 1, sum))


# Создание нового фрейма --------------------------------------------------

# 1. Обработка дат для приведения их к стандартному формату

# Избавимся от лишних символов
test_dates <- gsub("X", "", test_dates)

# Вытащим из вектора дат месяцы, дни и годы
months <- as.numeric(stringr::str_extract(string = test_dates,
                                          pattern = "^\\d+"))

days <- as.numeric(gsub(pattern = "\\.",
                        replacement = "",
                        x = stringr::str_extract(string = test_dates,
                                                 pattern = "\\.\\d+\\.")))

years <- 2000 + as.numeric(gsub(pattern = "\\.",
                                replacement = "",
                                x = stringr::str_extract(string = test_dates,
                                                         pattern = "\\.\\d+$")))

# Преобразуем их к единому формату дат
date_time <- ISOdate(year = years, month = months, day = days)
date <- as.Date(date_time)

# Удаление переменных
rm("months", "days", "years", "test_dates", "date_time")

# 2. Транспонирование данных и приведение к новой таблице на основе исходной
# Измерения в исходном фрейме начинаются с 4 столбца, следовательно
# сделаем выборку всех строк по столбцам с 4 по последний и транспонируем,
# поскольку в пределах данного куска таблицы все данные однотипны
new_table <- data.frame(date = date,
                        t(as.matrix(df[,4:ncol(df)])),
                        row.names = 1:(ncol(df) - 3))
new_table_deaths <- data.frame(date = date,
                               t(as.matrix(df_deaths[,4:ncol(df_deaths)])),
                               row.names = 1:(ncol(df_deaths) - 3))
new_table_recovered <- data.frame(date = date,
                                  t(as.matrix(df_recovered[,4:ncol(df_recovered)])),
                                  row.names = 1:(ncol(df_recovered) - 3))

colnames(new_table) <- c("date", country_names)
colnames(new_table_deaths) <- c("date", country_names_deaths)
colnames(new_table_recovered) <- c("date", country_names_recovered)

# Экспорт -----------------------------------------------------------------
# Экспортируем подготовленные данные в csv-файл
if (!dir.exists("output_csv")) {
  dir.create("output_csv")
}
write.csv(x = new_table,
          file = "output_csv/data_conf_output.csv")
write.csv(x = df_meta,
          file = "output_csv/metadata_conf.csv")
write.csv(x = new_table_deaths,
          file = "output_csv/data_deaths_output.csv")
write.csv(x = df_deaths_meta,
          file = "output_csv/metadata_deaths.csv")
write.csv(x = new_table_recovered,
          file = "output_csv/data_recovered_output.csv")
write.csv(x = df_recovered_meta,
          file = "output_csv/metadata_recovered.csv")


# Экспортируем данные в xlsx
if (!dir.exists("output_xlsx")) {
  dir.create("output_xlsx")
}
openxlsx::write.xlsx(x = new_table,
                     file = "output_xlsx/data_conf_output.xlsx")
openxlsx::write.xlsx(x = df_meta,
                     file = "output_xlsx/metadata_conf.xlsx")
openxlsx::write.xlsx(x = new_table_deaths,
                     file = "output_xlsx/data_deaths_output.xlsx")
openxlsx::write.xlsx(x = df_deaths_meta,
                     file = "output_xlsx/metadata_deaths.xlsx")
openxlsx::write.xlsx(x = new_table_recovered,
                     file = "output_xlsx/data_recovered_output.xlsx")
openxlsx::write.xlsx(x = df_recovered_meta,
                     file = "output_xlsx/metadata_recovered.xlsx")


# Удаление данных сессии --------------------------------------------------
rm(list = ls())

library(dplyr)
library(ggplot2)
library(forecast)

# Импорт подтверждённых заболеваний -------------------------------------------
df_confirmed <- read.csv("./output_csv/data_conf_output.csv")
df_confirmed$date <- as.Date(df_confirmed$date)
df_confirmed$World <- rowSums(df_confirmed[, 3:ncol(df_confirmed)])

# Импорт выздоровлений --------------------------------------------------------
df_recovered <- read.csv("./output_csv/data_recovered_output.csv")
df_recovered$date <- as.Date(df_recovered$date)
df_recovered$World <- rowSums(df_recovered[, 3:ncol(df_recovered)])

# Импорт смертей --------------------------------------------------------------
df_deaths <- read.csv("./output_csv/data_deaths_output.csv")
df_deaths$date <- as.Date(df_deaths$date)
df_deaths$World <- rowSums(df_deaths[, 3:ncol(df_deaths)])
```

# Введение

В данной работе ставится задача изучить показатели динамики заболеваемости 
Covid19 в России и рассмотреть качественный пример парного развития динамики 
заболеваемости Covid19 в двух странах с точки зрения моделей взаимодействия, 
построенных на основе систем дифференциальных уравнений.

Ранее был получен значительный класс результатов, относящийся к 
исследованию динамики развития природных систем на основе классических 
дифференциальных моделей. Среди таких моделей широко известны модель Форрестера [2,3],
модель Гомперца [6], модель линейного убывания темпов [8]. Подобно любой другой модели 
развития популяций, динамика численности заболевших Covid19 может отражать 
динамику распространения вируса как динамику популяции.

В ходе рассмотрения данной проблемы необходимо провести исследование медленных 
движений ряда данных динамики численности заболевших Covid19, оценить характерные 
значения почти-периодических компонент ряда, провести качественный анализ 
будущей тенденции заболеваемости.

За основу исследования трендовой составляющей ряда будет взята классическая 
дифференциальная постановка задачи моделирования динамики численности популяции 
на основе модели ограниченного роста Гомперца[6, 8-12]. 

При исследовании почти-периодических компонент необходимо обратиться к 
результатам исследований относительно применения функций, идентифицирующих 
почти-периодические зависимости, а именно: автокорреляционная функция[1] и функция 
Альтера-Джонса[8, 10-12].

В основе анализа парной динамики предложены методы исследования взаимодействия 
реальных данных динамики процессов на основе дифференциальной модели с логистической поправкой [4,5]. Такие модели применяются при анализе реальных данных численности популяций и видов на основе их механизма взаимодействия, когда одна популяция является "хищниками", другая "жертвами", однако не факт, что полученная модель в данном примере будет обладать необходимыми свойствами для такой интерпретации.




# Теория методов анализа

## Автокорреляционная функция

Автокорреляционная функция — зависимость взаимосвязи между функцией (сигналом) и её сдвинутой копией от величины временного сдвига [1].
Для детерминированных сигналов автокорреляционная функция (АКФ) сигнала $f(t)$ определяется интегралом:

$$
  {\displaystyle \Psi (\tau )=\int _{-\infty }^{\infty }f(t)f^{*}(t-\tau )\mathrm {d} t}
$$
и показывает связь сигнала (функции $f(t)$) с копией самого себя, смещённого на величину $\tau$ . Звёздочка означает комплексное сопряжение.

## Функция Альтера-Джонса

Для выявления периодов, свободных по возможности от априорных предположений, используем подход, который опирается, прежде всего, на фундаментальное характеристическое свойство периода функции, состоящее в повторении значений функции через интервал изменения независимой переменной равный периоду

$$
  f(t + \tau) - f(t) = 0
$$

Вводится следующее определение почти–периодической функции: число $\tau$ называется $\epsilon$ – почти–периодом ($\epsilon$ – смещением) 
функции $f(t)$ $(- \infty < t < \infty)$, если для всех t выполняется неравенство

$$
  \left| f(t + \tau) - f(t) \right| < \epsilon
$$

Если $f(t)$ – периодическая функция и $\tau$ – ее период, то есть $f(t + \tau)$ = $f(t)$, то, очевидно, $\tau$ является также и почти–периодом для любого $\epsilon > 0$, точно так же, как и любое число вида $n \tau$ $(n = \pm1 , \pm 2,…)$.

Для дискретного случая, если $n$ - общее число отсчетов функции $f(t)$, заданной экспериментальными значениями, вводится следующая метрика для определения почти периодов:

$$
  a(\tau) = \frac{1}{n - \tau} \sum_{t = 1}^{n - \tau}  \left| f(t + \tau) - f(t) \right|.
$$

Эта функция называется сдвиговой или функцией Альтера-Джонса.

Система почти - периодов $\tau$ функции $f(t)$ может быть определена как совокупность локальных минимумов сдвиговой функции

$$
  \tau = arg min\left[ a(\tau) \right] , \tau_{min} < \tau < \tau_{max}
$$

Функция Альтера–Джонса определяет среднее расстояние по оси ординат между точками, расположенными на расстоянии τ по оси абсцисс друг от друга.

## Модель Гомперца

Дифференциальное уравнение модели Гомперца

$$
 \frac{dy}{dt} = A e^{-kt} \cdot y
$$

Из исходного уравнения модели Гомперца получается следующая анаморфоза:

$$
  ln \left( \frac{1}{y} \frac{dy}{dt} \right) = ln \left( A \right) - kt
$$

Построение данных, соответствующих модели Гомперца, даёт спрямление в координатах $ln \left( \frac{1}{y} \frac{dy}{dt} \right) \sim t$. Это задаёт алгоритм оп-
ределения параметров уравнения Гомперца. В этом случае по линейному участку зависимости определяем параметр k, который представлен углом наклона прямой к оси абсцисс.

В точке перегиба 

$$
   \frac{1}{y} \frac{dy}{dt} = k \text{      } или \text{      } ln \left( \frac{1}{y} \frac{dy}{dt} \right)  = ln \left( k \right) 
$$


Т.е вычисляем логарифм угла наклона и откладываем полученное значение на оси ординат как линию постоянного уровня. Пересечение этой линии с исходной прямой определяет время достижения точки перегиба на кривой, характеризующей суммарное количество добытого к данному моменту ресурса. Это позволяет определить положение точки перегиба.

Следующая анаморфоза получается из уравнения, которое является решением дифференциального уравнения:


$$
  \frac{1}{y} \frac{dy}{dt} = k\left( ln(y_\infty) - ln(y) \right)
$$

Таким образом, анаморфозой, соответствующей линейной зависимости между характеристиками системы, являются координаты $\frac{1}{y} \frac{dy}{dt} \sim ln(y)$. По углу наклона линейного участка зависимости определяем значение параметра k. Продолжение линейного участка до пересечения с осью абсцисс позволяет определить значение $ln(y_\infty)$.

Определим дополнительный способ идентификации $ln(y_\infty)$.Запишем интеграл уравнения Гомперца в виде

$$
  ln(y(t)) = ln(y_\infty) - \left(\frac{A}{k}\right) e^{-kt}
$$

$$
  ln(y(t+\tau)) = ln(y_\infty) - \left(\frac{A}{k}\right) e^{-kt} e^{-k\tau}
$$

для текущего момента времени и смещенного от него на пробный период. Найдем разность двух последних уравнений и подставим в предыдущее уравнение:

$$
  ln(y(t+\tau)) =  e^{-k\tau} \cdot ln(y(t)) + (1 -  e^{-k\tau}) \cdot ln(y_\infty)
$$

Отсюда в фазовой плоскости значений, принадлежащих к двум различным моментам времени, получим линейную зависимость.

## Дифференциальная модель взаимодействия процессов

Если динамическая система представлена двумя процессами во времени $\left( x(t), y(t) \right)$, тогда модель взаимодействия динамики развития процессов во времени описывается следующей дифференциальной системой второго порядка:

$$
  \frac{dx}{dt} = x \cdot \left(\beta_{1} - \alpha_{1} \cdot y \right)
$$

$$
  \frac{dy}{dt} = y \cdot \left(\beta_{2} - \alpha_{2} \cdot x \right)
$$

Данная система иллюстрирует в своём частном случае при $\beta_{2} < 0$ и $\alpha_{2} < 0$ классическую модель "хищник-жертва".

Для реальных процессов, имея значения рядов, можно идентифицировать параметры данной системы на основе анаморфоз вида:

$$
  \frac{dx}{x \cdot dt} = \beta_{1} - \alpha_{1} \cdot y
$$

$$
  \frac{dy}{y \cdot dt} = \beta_{2} - \alpha_{2} \cdot x.
$$

Тогда, линейная модель на спрямляющемся участке графика будет содержать в себе параметры динамической системы, показаной выше.

# Анализ динамики заболеваний Covid19 в России

```{r, echo=F}
df_Russia <- df_confirmed %>% dplyr::select(date, contains("Russia")) %>%
  dplyr::mutate(diff_conf = c(0, diff(Russia.)), log_diff = log(diff_conf + 1), rownum = 1:nrow(df_confirmed))
```

## Графическое предобследование

Проиллюстрируем динамику заболеваемости в России с помощью графика в следующих координатах: по оси абсцисс отложим дни с момента "2021-01-22", а по оси ординат значения заболеваний в России каждый день суммарно по всем регионам. Также оранжевыми линиями отобразим пики на графике, а именно локальные максимумы "волн" заражений. Между максимумами отложим равные интервалы в 114 дней и получим локальные минимумы "волн" заражений.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
predict_forward = 110
period = 114
date_max = which.max(df_Russia$diff_conf)
step_y = 2500
step_x = 50

plot(x = df_Russia$rownum, y = df_Russia$diff_conf,
     col = "black", type = "o", pch = 19, cex = I(0.8), lwd = I(0.5),
     main = "График динамики заражений Covid19 в России",
     xlab = paste0("Дни с даты ", df_Russia$date[1]),
     ylab = "Прирост заболевших, чел",
     xlim = c(0, max(df_Russia$rownum) + predict_forward))
abline(v = date_max + period * (-3:2), col = "orange")
text(x = date_max + period * (-3:2) - 20, y = 2500,
     labels = c(df_Russia$date[date_max + period * (-2)] - period,
                df_Russia$date[date_max + period * (-2:1)],
                df_Russia$date[date_max + period] + period))
abline(h = seq(0, max(df_Russia$diff_conf) + step_y, step_y), 
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = seq(0, max(df_Russia$rownum) + predict_forward, step_x),
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = as.numeric(Sys.Date() - df_Russia$date[1]), col = "red",
       lty = 4, lwd = I(1.5))
text(x = as.numeric(Sys.Date() - df_Russia$date[1]) + step_x %/% 2, 
     y = df_Russia$diff_conf[nrow(df_Russia)] - step_y %/% 2,
     labels = paste0(Sys.Date(), ": ", df_Russia$diff_conf[nrow(df_Russia)]))
```

При помощи графического предобследования было определено характерное время смены тенденции процесса, а именно $T = 114$ дней для России по текущим данным. Определены даты пиковых заражений и даты локальных минимумов.

  1. Первый максимум 2020-05-10: `r df_Russia$diff_conf[df_Russia$date == as.Date("2020-05-10")]`.
  2. Первый минимум 2020-09-01: `r df_Russia$diff_conf[df_Russia$date == as.Date("2020-09-01")]`.
  3. Второй максимум: 2020-12-24: `r df_Russia$diff_conf[df_Russia$date == as.Date("2020-12-24")]`.
  4. Второй минимум: 2021-04-17: `r df_Russia$diff_conf[df_Russia$date == as.Date("2021-04-17")]`

## Анализ быстрых движений

Анализ быстрых движений подразумевает исследование сезонной компоненты относительно трендовой составляющей динамики заболеваемости. По построенному графику в разделе графического предобследования можно сказать о том, что в данной системе присутствует очень сильно выраженный тренд и очень маленькие, по сравнению с трендовыми значениями, колебательные составляющие.

Для того чтобы охарактеризовать колебательные движения относительно тренда необходимо произвести исследование динамики относительно тренда на почти-периодические компоненты, то есть найти характерные времена почти-периода. Для того чтобы это сделать, сперва необходимо удалить тренд из ряда. Это можно сделать либо простым численным дифференцированием, либо специальными функциями исключения тренда.

Функция исключения тренда:

$$
  R(t) = ln \left( \frac{y_{t - 1} * y_{t + 1}}{y_{t}^2} \right).
$$

Построим график функции исключения тренда исходной динамики:

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
plot(x = 1:(nrow(df_Russia) - 2), 
     y = log(df_Russia$diff_conf[-(1:2)] * df_Russia$diff_conf[-((nrow(df_Russia) - 1):nrow(df_Russia))] / df_Russia$diff_conf[-c(1, nrow(df_Russia))]^2),
     main = "График исключения тренда для исходного временного ряда",
     ylab = "Значения функции исключения тренда для динамики заболеваемости",
     xlab = "Дни от 2020-01-22",
     type = "o",
     pch = 19,
     ylim = c(-0.5, 0.5))
abline(v = seq(0, 600, 50), lty = 2, col = "grey", lwd = I(0.5))
abline(h = seq(-3000, 3000, 250), lty = 2, col = "grey", lwd = I(0.5))

```

К данному ряду применим автокорреляционную функцию и функцию Альтера-Джонса для поиска характерного времени $\tau$ - времени почти-периода малых колебаний относительно тренда:

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
max_lag <- 100
acf_Rus_conf <- acf(x = diff(df_Russia$diff_conf), 
                    lag.max = max_lag, demean = TRUE, plot = FALSE)
plot(x = acf_Rus_conf$lag, y = acf_Rus_conf$acf,
     type = "o", pch = 19, col = "red3", cex = I(0.8),
     main = "График автокореляций для прироста заболевших",
     xlab = "Лаги по времени, дни",
     ylab = "Автокорреляции ряда",
     xaxt = "n")
abline(v = 7 * (1:20), col = "blue2", lty = 3, lwd = I(0.5))
abline(h = c(-1:1) * 1.96 * (1 / sqrt(nrow(df_Russia))),
       lty = 2, lwd = I(0.5))
axis(1, seq(0, max_lag, 7))
abline(h = seq(0, 1, 0.1), col = "grey", lty = 2, lwd = I(0.5))
```


```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
MariaRemark.Alter_Johns <- function(ts, p = 1) {
  lents <- length(ts)
  a <- numeric(length = lents - 1)
  for (i in 1:(lents-1)) {
    a[i] <- 1/(lents - i) * sum(abs(ts[1:(lents - i)] - ts[(1 + i):lents])^(p))^(1/p)
  }
  return(a)
}

at_diff_Russ_p2 <- MariaRemark.Alter_Johns(diff(df_Russia$diff_conf), p = 2)

plot(at_diff_Russ_p2,
     type = "o", col = "red2", pch = 19, cex = I(0.8),
     xlim = c(0, max_lag), ylim = c(min(at_diff_Russ_p2[1:max_lag]),
                                    max(at_diff_Russ_p2[1:max_lag])),
     main = "График функции Альтера-Джонса для p = 2",
     xlab = "Лаги по времени, дни",
     ylab = "Значения функции Альтера-Джонса",
     xaxt = "n")
abline(v = 7 * (1:20), col = "blue2", lty = 3, lwd = I(0.5))
axis(1, seq(0, max_lag, 7))
```

На основе функции Альтера-Джонса и автокорреляционной фунции нами было получено характерное время почти-периода $\tau = 7$ дней, или неделя.

На основе данной информации можно предложить подставить данный параметр в STL разложение данного ряда для получения трех отдельных компонент: сезонности, тренда и шума:

```{r, echo = F, dpi = 1024, out.height=1200, out.width=800}
stl_model <- log(df_Russia$log_diff[-(1:100)])
stl_model <- stl(x = ts(stl_model, frequency = 7), s.window = "periodic")
plot(stl_model)
```

```{r, echo = F, dpi = 1024}
st_matrix <- as.matrix(stl_model$time.series)
plot(x = df_Russia$rownum[-(1:100)],
     y = df_Russia$diff_conf[-(1:100)],
     type = "l",
     col = "red",
     main = "Оценка тренда и сезонности и тренда по STL",
     ylab = "Заболеваемость каждый день, чел",
     xlab = "Дни от 2020-01-22")
lines(x = df_Russia$rownum[-(1:100)],
      y = exp(exp(st_matrix[, 1] + st_matrix[, 2])),
      type = "l",
      col = "blue")
abline(v = seq(0, 600, 20), col = "grey", lty = 2)
abline(h = seq(0, 40000, 2000), col = "grey", lty = 2)
legend(x = 100, y = 30000, legend = c("Реальные данные", "STL тренд + сезонность"),
       col = c("red", "blue"), lty = c(1, 1))
```


Сезонность, оцениваемая по STL является постоянной, с одинаковым периодом и амплитудой, поэтому, если в ряде присутствуют регулярные почти-периодические колебания, можно воспользоваться данным приёмом для оценки краткосрочного прогноза, сложив оцениваемый тренд и сезонность.

Как мы видим из последнего графика, аппроксимация без шума довольно точна даже на маленьких интервалах, что позволяет с высокой степенью доверия относиться к такой оценке сезонности.

При помощи STL разложения можно получить ряды данных, которые можно анализировать по-отдельности. Таким образом выделив колебания относительно тренда из исходного ряда, можно анализировать только медленные движения ряда, не обращая внимание на регулярные скачки в изменении показателя.

## Анализ медленных движений ряда

Предварительно рассмотрим два повторяющихся пика на графике динамики численности заболевших, совместив их максимумы "друг под другом", таким образом мы сможем оценить совпадающие критические уровни в развитии системы на данных интервалах и оценить схожесть тендеции развития на каждой из "волн" заболеваемости. Для совмещения значений двух пиков отнормируем больший пик к меньшему делением значений на максимальное значение большего ряда и умножим их на максимальное значение меньшего. По пропорциям получим исходную форму графика, что позволит на уровне относительных величин сравнивать формы кривых динамики развития системы.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
interval1 <- 1:(date_max - 2 * period - 1)
interval2 <- (date_max - 2 * period):(date_max - period - 1)
interval3 <- (date_max - period):(date_max - 1)
interval4 <- (date_max):(date_max + period - 1)

plot(x = df_Russia$date[c(interval1, interval2)],
     y = df_Russia$diff_conf[c(interval1, interval2)], type = "o", pch = 19,
     xlab = paste("Даты со дня", df_Russia$date[1]),
     ylab = "Прирост заражений, чел",
     main = "Совмещённый график двух пиков",
     xlim = c(df_Russia$date[1], df_Russia$date[length(c(interval3, interval4))]),
     ylim = c(0, max(df_Russia$diff_conf[c(interval1, interval2)])))
abline(v = df_Russia$date[which.max(df_Russia$diff_conf[c(interval1, interval2)])], col = "red")
text(x = df_Russia$date[which.max(df_Russia$diff_conf[c(interval1, interval2)])] + 10,
     y = max(df_Russia$diff_conf[c(interval1, interval2)]) / 3,
     labels = df_Russia$date[which.max(df_Russia$diff_conf[c(interval1, interval2)])])
abline(h = max(df_Russia$diff_conf[c(interval1, interval2)])/1.44, col = "blue")
abline(v = df_Russia$date[which.max(df_Russia$diff_conf[c(interval1, interval2)])] + 36)
text(x = df_Russia$date[which.max(df_Russia$diff_conf[c(interval1, interval2)])] + 36 + 10,
     y = max(df_Russia$diff_conf[c(interval1, interval2)]) / 3,
     labels = df_Russia$date[which.max(df_Russia$diff_conf[c(interval1, interval2)])] + 36)
lines(x =  df_Russia$date[c(interval3, interval4)] - (max(df_Russia$date[c(interval1, interval2)]) - min(df_Russia$date[c(interval1, interval2)])),
      y = df_Russia$diff_conf[c(interval3, interval4)] / max(df_Russia$diff_conf) * max(df_Russia$diff_conf[c(interval1, interval2)]),
      lty = 2, col = "grey4")
abline(h = max(df_Russia$diff_conf[c(interval1, interval2)]), col = "blue")
text(x = df_Russia$date[3], y = max(df_Russia$diff_conf[c(interval1, interval2)]), 
     labels = max(df_Russia$diff_conf[c(interval1, interval2)]))
text(x = df_Russia$date[3], y = max(df_Russia$diff_conf[c(interval1, interval2)]) / 1.44, 
     labels = round(max(df_Russia$diff_conf[c(interval1, interval2)]) / 1.44))
```

Как видим исходя из графика, значения пиков совмещены вместе со значениями в 1.44 раза меньше по сравнению с наибольшим значением волны. Это является прямым доказательством связи данных участков друг с другом, а также показывает возможное проявление модели Гомперца в качестве основной модели развития системы во времени, то есть трендовой модели.
Время между максимальным значением и значением, меньшим в 1.44 раза lag = 36 дней.

## Исследование тренда на основе модели Гомперца

Модель Гомперца - дифференциальная модель ограниченного роста, отражающая по-сути развитие популяций, в основе которой лежит понимание ограничения на рост системы. Такая модель является наиболее точной среди остальных моделей развития популяций, ввиду несиметричности теоретической кривой решения. Началу процесса характерен резкий подъём, а после точки максимума скорости развития системы происходит уменьшение темпов роста с менее быстрой скоростью. Такая модель наиболее удобна с точки зрения аппроксимации реальных данных по причине наибольшей распространённости процессов с похожей динамикой.

Рассмотрим получение параметров модели Гомперца для реальных данных на основе спрямления в функциональных координатах. Теоретически модель Гомперца была описана в соответствующем разделе, также и описаны методы получения параметров модели.

Для первого интервала в 228 дней от начала процесса построим график в функциональных координатах анаморфозы модели Гомперца.

$$
  ln \left( \frac{1}{y} \frac{dy}{dt} \right) \sim t
$$


```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
diff_russia12_y <- df_Russia$diff_conf[c(interval1, interval2)]
diff_russia12_x <- c(interval1, interval2)
gmp12_y <- log(diff_russia12_y/cumsum(diff_russia12_y))

plot(x = diff_russia12_x,
     y = gmp12_y,
     type = "o",
     pch = 19,
     cex = I(0.8),
     main = "Анаморфоза Гомперца ln(y_dot / y) ~ t на первом интервале в 228 дней",
     ylab = "Значения анаморфозы Гомперца",
     xlab = paste("Дни с", df_Russia$date[1]))
gmp12_alpha = -0.033  # Угол наклона модели Гомперца на анаморфозе Гомперца
gmp12_beta = 0.67      # Пересечение с 0 в анаморфозе Гомперца
abline(a = gmp12_beta, b = gmp12_alpha)
abline(h = log(-gmp12_alpha))
arrows(x0 = (log(-gmp12_alpha) - gmp12_beta) / gmp12_alpha,
       x1 = (log(-gmp12_alpha) - gmp12_beta) / gmp12_alpha,
       y0 = log(-gmp12_alpha),
       y1 = 0)
text(x = (log(-gmp12_alpha) - gmp12_beta) / gmp12_alpha, y = 0,
     labels = df_Russia$date[round((log(-gmp12_alpha) - gmp12_beta) / gmp12_alpha)])
text(x = 25, y = log(-gmp12_alpha) + 0.25, labels = paste("ln(k) =", round(log(-gmp12_alpha), 2)))
text(x = 85, y = -1, labels = paste("-k =", gmp12_alpha, "; b =", gmp12_beta))
abline(h = 0, lty = 2)
```

На графике в координатах анаморфозы Гомерца видим спрямление участка данных. Данный факт говорит о принадлежности данного участка дифференциальной модели Гомперца по определению функциональных координат, в которых построен график. 

Параметры прямой в функциональных координатах: `r paste("ln(-k) =", round(log(-gmp12_alpha), 2),"; -k =", gmp12_alpha, "; b =", gmp12_beta)`. И тогда получаем итоговую зависимость вида:

$$
  ln\left( \frac{1}{y} \frac{dy}{dt} \right) = -0.033 \cdot t + 0.67
$$

Итоговая теоретическая кривая Гомперца имеет вид:

$$
  \frac{dy}{dt} = e^{-0.033 \cdot t + 0.67} \cdot y,
$$

или после преобразования:

$$
  \frac{dy}{dt} = Ae^{-k \cdot t} \cdot y = 1.95 \cdot e^{-0.033 \cdot t} \cdot y,
$$

где $y$ - кумулятивная сумма исходного рассматриваемого ряда динамики. 

Вернув данные параметры в исходное уравнение получим оценку тренда по модели Гомперца. Отобразим теоретическую модельную кривую и исходные данные на графике.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
plot(x = diff_russia12_x, y = diff_russia12_y,
     col = "black", type = "o", pch = 19,
     main = "Модель Гомперца на основе первого интервала",
     xlab = paste("Дни с", df_Russia$date[1]),
     ylab = "Приросты числа заболевших, чел")
lines(x = diff_russia12_x,
      y = exp(gmp12_alpha * diff_russia12_x + gmp12_beta) *
        cumsum(diff_russia12_y), col = "red")
abline(v = (log(-gmp12_alpha) - gmp12_beta) / gmp12_alpha, col = "red")
abline(v = 160)
abline(v = seq(0, 230, 10), lty = 2, col = "grey", lwd = I(0.5))
abline(h = seq(0, 12000, 1000), lty = 2, col = "grey", lwd = I(0.5))
```

На графике видно, что первые 160 значений ряда данных подчинялись с определённой точностью полученной теоретической зависимости. В точке $t = 160$ модельная кривая и реальные данные расходятся в значениях в большую сторону у реальных данных, что может символизировать о начале переходного процесса перед реализацией новой волны заражений.

Отобразим полученную теоретическую Гомперцевую кривую на всей области определения исходного ряда данных.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
plot(x = df_Russia$rownum, y = df_Russia$diff_conf,
     col = "black", type = "o", pch = 19, cex = I(0.8), lwd = I(0.5),
     main = "График динамики заражений Covid19 в России",
     xlab = paste0("Дни с даты ", df_Russia$date[1]),
     ylab = "Прирост заболевших, чел",
     xlim = c(0, max(df_Russia$rownum) + predict_forward))
abline(v = date_max + period * (-3:2), col = "orange")
text(x = date_max + period * (-3:2) - 20, y = 2500,
     labels = c(df_Russia$date[date_max + period * (-2)] - period,
                df_Russia$date[date_max + period * (-2:1)],
                df_Russia$date[date_max + period] + period))
abline(h = seq(0, max(df_Russia$diff_conf) + step_y, step_y), 
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = seq(0, max(df_Russia$rownum) + predict_forward, step_x),
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = as.numeric(Sys.Date() - df_Russia$date[1]), col = "red",
       lty = 4, lwd = I(1.5))
text(x = as.numeric(Sys.Date() - df_Russia$date[1]) + step_x %/% 2, 
     y = df_Russia$diff_conf[nrow(df_Russia)] - step_y %/% 2,
     labels = paste0(Sys.Date(), ": ", df_Russia$diff_conf[nrow(df_Russia)]))
lines(x = df_Russia$rownum,
      y = exp(gmp12_alpha * df_Russia$rownum + gmp12_beta) *
        cumsum(df_Russia$diff_conf), col = "red")
abline(v = (log(-gmp12_alpha) - gmp12_beta) / gmp12_alpha, col = "red")
```

В рамках анализа исключим из рассмотрения полученную теоретическую зависимость по модели Гомперца и оценим возможность реализации новой модели на второй "волне" заражений. Отобразим на графике занчения после исключения первой теоретической Гомперцевой кривой. Полученный ряд имеет незначительные флуктуации вначале из-за точности трендовой аппроксимации, а также имеет только один ярко выраженный пик на диапазоне второй волны.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024}
df_Russia$wo_gmp1 <- df_Russia$diff_conf - exp(gmp12_alpha * df_Russia$rownum + gmp12_beta) *
  cumsum(df_Russia$diff_conf)

plot(x = df_Russia$rownum, y = df_Russia$wo_gmp1,
     col = "black", type = "o", pch = 19, cex = I(0.8), lwd = I(0.5),
     main = "График динамики заражений Covid19 в России",
     xlab = paste0("Дни с даты ", df_Russia$date[1]),
     ylab = "Прирост заболевших, чел",
     xlim = c(0, max(df_Russia$rownum) + predict_forward))
abline(v = date_max + period * (-3:2), col = "orange")
text(x = date_max + period * (-3:2) - 20, y = 2500,
     labels = c(df_Russia$date[date_max + period * (-2)] - period,
                df_Russia$date[date_max + period * (-2:1)],
                df_Russia$date[date_max + period] + period))
abline(h = seq(0, max(df_Russia$diff_conf) + step_y, step_y), 
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = seq(0, max(df_Russia$rownum) + predict_forward, step_x),
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = as.numeric(Sys.Date() - df_Russia$date[1]), col = "red",
       lty = 4, lwd = I(1.5))
text(x = as.numeric(Sys.Date() - df_Russia$date[1]) + step_x %/% 2, 
     y = df_Russia$diff_conf[nrow(df_Russia)] - step_y %/% 1.5,
     labels = paste0(Sys.Date(), ": ", df_Russia$diff_conf[nrow(df_Russia)]))
```

Попробуем для данного ряда оценить параметры модели Гомперца тем же способом через функциональные координаты - анаморфозу модели Гомперца.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024, warning=FALSE}
plot(x = df_Russia$rownum, 
     y = log(df_Russia$wo_gmp1 / cumsum(df_Russia$wo_gmp1)),
     main = "Анаморфоза Гомперца для всего полученного интервала",
     ylab = "Значения анаморфозы Гомперца",
     xlab = paste("Дни с", df_Russia$date[1]))
abline(h = 0, lty = 2)
gmp12_2_alpha <- -0.021
gmp12_2_beta <- 2.8
abline(a = gmp12_2_beta, b = gmp12_2_alpha, col = "red")
abline(h = log(-gmp12_2_alpha), col = "red")
arrows(x0 = (log(-gmp12_2_alpha) - gmp12_2_beta) / gmp12_2_alpha,
       x1 = (log(-gmp12_2_alpha) - gmp12_2_beta) / gmp12_2_alpha,
       y0 = log(-gmp12_2_alpha),
       y1 = 0, col = "red")
text(x = (log(-gmp12_2_alpha) - gmp12_2_beta) / gmp12_2_alpha, y = 0,
     labels = df_Russia$date[round((log(-gmp12_2_alpha) - gmp12_2_beta) / gmp12_2_alpha)])
text(x = 10, y = log(-gmp12_2_alpha) - 0.25, 
     labels = paste("ln(k) =", round(log(-gmp12_2_alpha), 2)))
text(x = 400, y = -3, labels = paste("-k =", gmp12_2_alpha, "; b =", gmp12_2_beta))
abline(v = seq(0, 600, 50), lty = 2, col = "grey", lwd = I(0.5))
abline(h = seq(-10, 4, 1), lty = 2, col = "grey", lwd = I(0.5))
```

Полученные параметры `r paste("-k =", gmp12_2_alpha, "; b =", gmp12_2_beta)` вернём обратно в модель Гомперца для построения теоретической кривой зависимости относительно реальных данных. И тогда получаем итоговую зависимость вида:

$$
  ln\left( \frac{1}{y} \frac{dy}{dt} \right) = -0.021 \cdot t + 2.8
$$

Итоговая теоретическая кривая Гомперца имеет вид:

$$
  \frac{dy}{dt} = e^{-0.021 \cdot t + 2.8} \cdot y,
$$

или после преобразования:

$$
  \frac{dy}{dt} = Ae^{-k \cdot t} \cdot y = 15.15 \cdot e^{-0.021 \cdot t} \cdot y,
$$

где $y$ - кумулятивная сумма исходного рассматриваемого ряда динамики. 

Покажем на графике истинные значения заболеваемости без первой "волны" и теоретически полученную зависимость по дифференциальной модели.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024, warning=FALSE}
stl_model1 <- stl(ts(log(df_Russia$diff_conf[interval4]), frequency = 7), s.window = "periodic")
stl_matrix1 <- as.matrix(stl_model1$time.series)

plot(x = df_Russia$rownum, y = df_Russia$wo_gmp1,
     col = "black", type = "o", pch = 19, cex = I(0.8), lwd = I(0.5),
     main = "График динамики заражений Covid19 в России",
     xlab = paste0("Дни с даты ", df_Russia$date[1]),
     ylab = "Прирост заболевших, чел",
     xlim = c(0, max(df_Russia$rownum) + predict_forward))
abline(v = date_max + period * (-3:2), col = "orange")
text(x = date_max + period * (-3:2) - 20, y = 2500,
     labels = c(df_Russia$date[date_max + period * (-2)] - period,
                df_Russia$date[date_max + period * (-2:1)],
                df_Russia$date[date_max + period] + period))
lines(x = df_Russia$rownum,
      y = exp(gmp12_2_alpha * df_Russia$rownum + gmp12_2_beta) *
        cumsum(df_Russia$wo_gmp1), col = "purple")
lines(x = df_Russia$rownum + 50,
      y = exp(gmp12_2_alpha * df_Russia$rownum + gmp12_2_beta) *
        cumsum(df_Russia$wo_gmp1), col = "blue")
abline(h = min(df_Russia$diff_conf[interval4]) * c(1, exp(1)), lty = 2, col = "red")
text(x = df_Russia$rownum[max(interval4)],
     y = min(df_Russia$diff_conf[interval4]) * c(1, exp(1)) - 700,
     labels = round(min(df_Russia$diff_conf[interval4]) * c(1, exp(1))) - 700)
abline(h = max(df_Russia$diff_conf), col = "red", lty = 2)
text(x = which.max(df_Russia$diff_conf) + 26, y = max(df_Russia$diff_conf) - 700,
     labels = max(df_Russia$diff_conf))
abline(v = c(df_Russia$rownum[max(interval3)],
             df_Russia$rownum[max(interval3)] + 36),
       col = "red", lty = 2)
abline(h = seq(0, max(df_Russia$diff_conf) + step_y, step_y), 
       lty = 2, lwd = I(0.5), col = "grey")
abline(v = seq(0, max(df_Russia$rownum) + predict_forward, step_x),
       lty = 2, lwd = I(0.5), col = "grey")
```

На графике видим неоднозначную картину, что произошло ввиду большого количества значений до реализации модели. Вначале из-за флуктуаций, модель Гомперца вела себя похожим образом. Теоретическая зависимость своим правым скатом хорошо объяснила правый край реальных данных, который отвечает за современную динамику, чего не случилось с левым краем. Получаем идеальное объяснение при сдвиге теоретической кривой на 50 дней вперёд. Таким образом, точно показать зависимость по модели Гомперца для второй волны нам не удалось. Удалось показать поразительное объяснение кусочной зависимости ряда данных от времени прим помощи модели ограниченного роста. Как и с первой реализацией модели, получилось что через некоторое время модель теряет свою объясняющую силу и срывается вниз, когда реальная зависимость идёт в рост.

Для точной перепроверки стоит проверить ещё вторую волну отдельно на своём интервале на соответствие модели Гомперца.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024, warning=FALSE}
gmp_diff2_it <- df_Russia$wo_gmp1[(date_max - period - 10):nrow(df_Russia)]
gmp_diff2 <- gmp_diff2_it - min(gmp_diff2_it)
plot(y = gmp_diff2,
     x = 1:length(gmp_diff2),
     xlab = paste("Дни от", as.Date("2021-01-22") + 228),
     ylab = "Заражения каждый день - 5000, чел",
     main = "Вторая волна заражений в России",
     type = "o", 
     pch = 19,
     cex = I(0.5),
     lwd = I(0.5))
abline(v = seq(0, 300, 25), lty = 2, col = "grey")
abline(h = seq(0, 30000, 2500), lty = 2, col = "grey")
``` 

Построим график в спрямляющих модель Гомперца координатах $ln\left( \frac{1}{y} \frac{dy}{dt} \right) \sim t$. Найдём параметры модели Гомперца по прямолинейной зависимости в заданной декартовой плоскости

```{r, echo = F, out.height=800, out.width=800, dpi = 1024, warning=FALSE}
plot(log(gmp_diff2 / cumsum(gmp_diff2)),
     cex = I(0.5), pch = 19, type = "p",
     main = "График анаморфозы Гомперца",
     ylab = "Значения натурального логарифма логарифмической производной",
     xlab = paste("Дни от", as.Date("2021-01-22") + 228))
abline(v = seq(0, 300, 25), lty = 2, col = "grey")
abline(h = seq(-8, 2, 1), lty = 2, col = "grey")
gmp_diff2_alpha <- -0.0222
gmp_diff2_beta <- -1.44
abline(a = gmp_diff2_beta, b = gmp_diff2_alpha, col = "red")
abline(h = 0)
abline(h = log(-gmp_diff2_alpha), col = "red")
arrows(x0 = (log(-gmp_diff2_alpha) - gmp_diff2_beta) / gmp_diff2_alpha,
       x1 = (log(-gmp_diff2_alpha) - gmp_diff2_beta) / gmp_diff2_alpha,
       y0 = log(-gmp_diff2_alpha),
       y1 = 0, col = "red")
text(x = (log(-gmp_diff2_alpha) - gmp_diff2_beta) / gmp_diff2_alpha, y = 0,
     labels = df_Russia$date[round((log(-gmp_diff2_alpha) - gmp_diff2_beta) / gmp_diff2_alpha)] + 228)
text(x = 20, y = log(-gmp_diff2_alpha) - 0.2, labels = paste("ln(k) =", round(log(-gmp_diff2_alpha), 2)))
text(x = 150, y = -3, labels = paste("-k =", gmp_diff2_alpha,"; b =", gmp_diff2_beta))
```

И тогда получаем итоговую зависимость вида:

$$
  ln\left( \frac{1}{y} \frac{dy}{dt} \right) = -0.0222 \cdot t - 1.44
$$

Итоговая теоретическая кривая Гомперца имеет вид:

$$
  \frac{dy}{dt} = e^{-0.0222 \cdot t - 1.44} \cdot y,
$$

или после преобразования:

$$
  \frac{dy}{dt} = Ae^{-k \cdot t} \cdot y = 0.237 \cdot e^{-0.22 \cdot t} \cdot y,
$$
где $y$ - кумулятивная сумма исходного рассматриваемого ряда динамики. 

После подстановки в модель всех данных получим аппроксимацию трендовой линии моделью, по которой можно оценить сходство модели и реальных данных.

```{r, echo = F, out.height=800, out.width=800, dpi = 1024, warning=FALSE}
gmp_diff2_approx <- exp(gmp_diff2_alpha * 1:length(gmp_diff2) + gmp_diff2_beta) * cumsum(gmp_diff2)
plot(y = gmp_diff2,
     x = 1:length(gmp_diff2),
     main = "Динамика второй волны заболеваемости",
     ylab = "Количество заражённых каждый день - 2000, чел",
     xlab = paste("Дни от", df_Russia$date[1] + 228),
     type = "o", 
     pch = 19,
     cex = I(0.5),
     lwd = I(0.5))
lines(x = 1:length(gmp_diff2_it), y = gmp_diff2_approx)
abline(h = seq(0, 30000, 2000), lty = 2, col = "grey")
abline(v = seq(0, 600, 10), lty = 2, col = "grey")
abline(v = c(125, 125 + 114), col = "orange")
abline(v = 125 + 97, col = "red")
```

Из графика, представленного выше, видно, что теоретическая кривая очень хорошо объясняет имеющиеся данные, однако теоретическая зависимость как и на первой волне обрывается спустя некоторое время. На данный момент это $lag2 = 97$ дней от точки максимума на второй волне.

По второй анаморфозе Гомперца можно определить, что точка максимума роста общей численности заболевших $y_\infty$ была преодолена на реальных данных.

```{r, echo = F, dpi = 1024, warning=FALSE}
plot(y = gmp_diff2 / cumsum(gmp_diff2),
     x = log(cumsum(gmp_diff2)),
     ylim = c(0, 0.1), xlim = c(11, 15.5), cex = I(0.6), pch = 19)
a <- -0.02
b <-  0.29876
abline(col = "red",
       a = b, b = a)
abline(h = 0, col = "red")
abline(v = -b / a, col = "red")
```

## Выводы

При анализе динамики роста числа заболевших Covid19 в России были получены численные и качественные результаты, касаемо тенденции развития заболевания на первых двух волнах, что даёт возможность сформировать общую оценку дальнейшей тенденции развития.

Были выявлены почти-периодические компоненты ряда со временем почти-периода в $\tau = 7$ дней. Это малые колебания численности новых заболевших относительно общего тренда. Недельная сезонность говорит о структурных проблемах в методике выявления новых заболевших и существенно осложняет процесс оценки точного числа заболевших в некотором будущем.

При помощи полученного характерного времени почти-периода можно выразить среднюю динамику относительно трендовой зависимости, выделить тренд и убрать из данных шумовые составляющие, которые иллюстрируют также случайную компоненту процесса. Выделить три компоненты тренд, сезонность и шум, можно по известному характерному времени почти-периода на основе STL-разложения. Получив динамику тренда в дальнейшем можно оценивать тенденцию ряда в общем смысле, не обращая внимание на сезонные колебания.

На основе анализа медленных движений ряда - трендового движения была выявлена принадлежность первых двух волн заболеваемости к классу процессов с лимитированными запасами энергии на продолжение роста как и у всех живых систем. Данные трендовые движения в первой и второй волне были проверены на принадлежность к модели Гомперца на основе процедуры преобразования координат зависимости и построения линейных аппроксимаций на функциональной плоскости. Полученные модели, показанные в работе, являются доказательством принадлежности трендовых колебаний как классу моделей с ограниченным ростом, так и к модели Гомперца в частности.

В двух наблюдаемых волнах при аппроксимации трендовой зависимости теоретической модельной кривой Гомперца было обнаружено, что реальный процесс через некоторое время после прохождения максимума сходил с теоретической зависимости переходя в другое структурное состояние. Такой же эффект был обнаружен и на второй волне, что может сигнализировать о наступлении очередного эпизода роста числа заболевших каждый день.

При исследовании пиков заболеваний был обнаружен большой цикл в 228 дней между максимумами и минимумами, что может являться критической отметкой, рубежом для системы, сигнализирующим о месте разворота тенденции развития заболевания в России.

# Анализ парных движений на фазовых плоскостях

## Предобследование парной динамики заболеваемости

Рассмотрим динамику заболеваемости Covid19 в двух странах, построим их графики заболеваемости во времени, а также фазовую плоскость. 

На графике динамики двух стран отложим по оси ординат натуральный логарифм ежедневных приростов больных Covid19, по оси абсцисс номер дня с момента начала мирового распространения `r df_confirmed$date[1]`. По данному графику мы сможем визуально оценить модель взаимодействия двух процессов на качественном уровне.

В качестве примера возьмём две страны с открытыми туристическими границами - Египет и Беларусь.


```{r Egypt_Belarus graphics, echo = F, dpi = 1024}
time_series_Egypt <- select(df_confirmed, contains("Egypt"))[, ]
time_series_Belarus <- select(df_confirmed, contains("Belarus"))[, ]

plot(x = 1:length(time_series_Belarus), y = c(0, log(diff(time_series_Belarus) + 1)),
     col = "red", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Парный график заболеваемости Беларусь и Египет",
     ylab = "Натуральный логарифм заболеваний каждый день, чел",
     xlab = paste("Дни с", df_confirmed$date[1]),
     ylim = c(min(c(0, log(diff(time_series_Belarus) + 1)), c(0, log(diff(time_series_Egypt) + 1))), 
              max(c(0, log(diff(time_series_Belarus) + 1)), c(0, log(diff(time_series_Egypt) + 1)))))
lines(x = 1:length(time_series_Egypt), y = c(0, log(diff(time_series_Egypt) + 1)),
      col = "blue", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19)
legend(x = 300, y = 2,
       legend = c("LN приросты Беларусь", "LN приросты Египет"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Egypt) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
```

График парной динамики показывает нам, что уровень заболеваемости, длительность тактов вспышек заболеваемости в двух странах находятся примерно на одном уровне. На последнем временном отрезке в 350 дней от начала измерений и до настоящего времени видим на графике динамики заболеваемости в Беларуси появившуюся недельную сезонность - коррекцию на некоторый момент времени, являющуюся ответной реакцией процесса на некоторые структурные изменения механизма измерения числа заболевших. Такое качественное изменение характера динамики процесса может существенно повлиять на дальнейший анализ данного процесса. 

На графике динамики заболеваемости в Египте видим на момент 28.05.2021 начало спада и точку перелома приростов заболевших Covid19, что означает возможное прохождение точки максимума заражений во время 3 волны массовых заражений.

Оценим длительность тактов переходных процессов спада и роста количества заболевших относительно точек максимума заражений на графике заболеваемости в Египте.

```{r Egypt takt, echo = F, dpi = 1024}
maxes_Egypt <- c(148, 345, 480)
tau = 30

plot(x = 1:length(time_series_Belarus), y = c(0, log(diff(time_series_Belarus) + 1)),
     col = "red", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Анализ тактов заболеваемости парного процесса",
     ylab = "Натуральный логарифм заболеваний каждый день, чел",
     xlab = paste("Дни с", df_confirmed$date[1]),
     ylim = c(min(c(0, log(diff(time_series_Belarus) + 1)), c(0, log(diff(time_series_Egypt) + 1))), 
              max(c(0, log(diff(time_series_Belarus) + 1)), c(0, log(diff(time_series_Egypt) + 1)))))
lines(x = 1:length(time_series_Egypt), y = c(0, log(diff(time_series_Egypt) + 1)),
      col = "blue", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19)
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Egypt) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
abline(v = maxes_Egypt, col = "orange2")
text(x = maxes_Egypt, y = 3.5, labels = df_confirmed$date[1] - 1 + maxes_Egypt)
abline(v = maxes_Egypt - tau, col = "green3")
text(x = maxes_Egypt - tau, y = 2.5, labels = df_confirmed$date[1] - 1 + maxes_Egypt - tau)
legend(x = 300, y = 2,
       legend = c("LN приросты Беларусь", "LN приросты Египет"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
abline(h = c(4.5, 7.5), col = "blue", lty = 2)
abline(h = c(4.9, 6.9), col = "red", lty = 2)

abline(h = 0)
```

Из расставленных точек максимума заболеваемости на графиках по Беларуси и Египту видим что в начале процесса существовал некоторый почти-периодический процесс с обеих сторон с лагом между процессами в `r tau` дней. Также видим что из-за структурного изменения процесса измерения числа заболевших в Беларуси такого эффекта не наблюдалось в последнюю волну. 

Для завершения исследования парного развития процесса заболеваемости в двух странах необходимо провести анализ динамики на фазовой плоскости динамик процессов. Произведём построение графика с осью ординат - заболеваемостью в Египте, и осью абсцисс - заболеваемостью в Беларуси:

```{r, echo = F, dpi = 1024}
plot(y = log(diff(time_series_Egypt) + 1), x = log(diff(time_series_Belarus) + 1),
     xlab = "Динамика заболеваемости в Беларуси в полулогарифмах",
     ylab = "Динамика заболеваемости в Египте в полулогарифмах",
     main = "График фазовой плоскости парной динамики",
     type = "p", 
     pch = 19, 
     lwd = I(0.5),
     cex = I(0.5))

radius_a = 0.9
radius_b = 1.2
center_x = 6
center_y = 6.1
points(x = c(center_x - radius_a, center_x, center_x + radius_a, center_x, center_x) - 0.1, 
       y = c(center_y, center_y, center_y, center_y + radius_b, center_y - radius_b), pch = 19, cex = I(1), col = "red")
abline(h = c(4.5, 7.5), col = "blue", lty = 2)
abline(v = c(4.9, 6.9), col = "red", lty = 2)
graphics::rect(6.9, 4.5, 9, 7.5, col = "blue", density = I(10))
```

На фазовой плоскости динамики двух процессов наблюдаем замкнутый контур завершённого полного такта взаимодействия двух процессов, после которого последовало продолжение огибающего контура в правой части графика. Наблюдаем такую же структурную навивку с отклонениями недельных колебаний в сторону исходной эллипсовой кривой такта взаимодействия двух процессов (выделено синими штрихами).

```{r, echo = F, dpi = 1024}
plot(x = 1:length(time_series_Belarus), y = c(0, log(diff(time_series_Belarus) + 1)),
     col = "red", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Анализ тактов заболеваемости парного процесса",
     ylab = "Натуральный логарифм заболеваний каждый день, чел",
     xlab = paste("Дни с", df_confirmed$date[1]),
     ylim = c(4, 8),
     xlim = c(60, 500))
lines(x = 1:length(time_series_Egypt), y = c(0, log(diff(time_series_Egypt) + 1)),
      col = "blue", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19)
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Egypt) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
abline(v = maxes_Egypt, col = "orange2")
text(x = maxes_Egypt, y = 3.5, labels = df_confirmed$date[1] - 1 + maxes_Egypt)
abline(v = maxes_Egypt - tau, col = "green3")
text(x = maxes_Egypt - tau, y = 2.5, labels = df_confirmed$date[1] - 1 + maxes_Egypt - tau)
legend(x = 300, y = 2,
       legend = c("LN приросты Беларусь", "LN приросты Египет"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
abline(h = c(4.5, 7.5), col = "blue", lty = 2)
abline(h = c(4.9, 6.9), col = "red", lty = 2)
```

```{r, echo = F, dpi = 1024}
plot(y = log(diff(time_series_Egypt) + 1), x = log(diff(time_series_Belarus) + 1),
     xlab = "Динамика заболеваемости в Беларуси в полулогарифмах",
     ylab = "Динамика заболеваемости в Египте в полулогарифмах",
     main = "График фазовой плоскости парной динамики",
     type = "o", 
     pch = 19, 
     lwd = I(0.5),
     cex = I(0.5), ylim = c(4.4, 7.6), xlim = c(4.5, 7.5))

radius_a = 1
radius_b = 1.3
center_x = 6
center_y = 6.1
points(x = c(center_x - radius_a, center_x, center_x + radius_a, center_x, center_x) - 0.1, 
       y = c(center_y, center_y, center_y, center_y + radius_b, center_y - radius_b), pch = 19, cex = I(1), col = "red")
abline(h = c(4.5, 7.5), col = "blue", lty = 2)
abline(v = c(4.9, 6.9), col = "red", lty = 2)
graphics::rect(6.9, 4.5, 9, 7.5, col = "blue", density = I(10))
```

Хорошим тестом для проверки как лага по времени отставания двух процессов друг относительно друга так и зависимости между ними с точки зрения системы дифференциальных уравнений может оказаться смещение на лаг отставания процесса друг относительно друга в сторону постановки "процесса под процесс" так, чтобы такты двух процессов оказались синхронизированными. В таком случае при подобном смещении на графике фазовой плоскости будут образовываться прямолинейные зависимости, обозначающие высокую степень корреляции двух процессов во времени.

```{r, echo = F, dpi = 1024}
plot(x = 1:length(time_series_Belarus) + tau, y = c(0, log(diff(time_series_Belarus) + 1)),
     col = "red", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Тест на смещение процесса заболеваемости во времени",
     ylab = "Натуральный логарифм заболеваний каждый день, чел",
     xlab = paste("Дни с", df_confirmed$date[1]),
     ylim = c(4, 8),
     xlim = c(60, 500))
lines(x = 1:length(time_series_Egypt), y = c(0, log(diff(time_series_Egypt) + 1)),
      col = "blue", type = "o", cex = I(0.5), lwd = I(0.5), pch = 19)
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Egypt) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
abline(v = maxes_Egypt, col = "orange2")
legend(x = 300, y = 2,
       legend = c("LN приросты Беларусь", "LN приросты Египет"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
abline(h = c(4.5, 7.5), col = "blue", lty = 2)
abline(h = c(4.9, 6.9), col = "red", lty = 2)
```

```{r, echo = F, dpi = 1024}
plot(y = log(diff(time_series_Egypt) + 1)[-(1:tau)], 
     x = log(diff(time_series_Belarus) + 1)[-((length(log(diff(time_series_Egypt) + 1)) - tau + 1):length(log(diff(time_series_Egypt) + 1)))],
     xlab = "Динамика заболеваемости в Беларуси в полулогарифмах",
     ylab = "Динамика заболеваемости в Египте в полулогарифмах",
     main = "Тест на смещение процесса заболеваемости во времени",
     type = "p", 
     pch = 19, 
     lwd = I(0.5),
     cex = I(0.5), ylim = c(4.4, 7.6), xlim = c(4.5, 7.5))
abline(h = c(4.5, 7.5), col = "blue", lty = 2)
abline(v = c(4.9, 6.9), col = "red", lty = 2)
graphics::rect(6.9, 4.5, 9, 7.5, col = "blue", density = I(10))

abline(a = 0.5, b = 0.8, col = "red")
abline(a = 1.0, b = 0.8, col = "red")
abline(a = 1.5, b = 0.8, col = "red")
```

Таким образом, так же на качественном уровне нами было получено заключение о высокой корреляции процессов после смещения их друг относительно друга на такт запаздывания.

## Постановка системы дифференциальных уравнений процесса взаимодействия

Предположим, что данное взаимодействие двух процессов может быть описано с помощью системы дифференциальных уравнений с логистической зависимостью:

$$
  \frac{dx}{dt} = x \cdot \left(\beta_{1} - \alpha_{1} \cdot y \right)
$$

$$
  \frac{dy}{dt} = y \cdot \left(\beta_{2} - \alpha_{2} \cdot x \right)
$$
Данная система иллюстрирует в своём частном случае при $\beta_{2} < 0$ и $\alpha_{2} < 0$ классическую модель "хищник-жертва".

**Исследование системы первого приближения.** По формуле Тейлора для системы функций, найдем вид системы уравнения в окрестности точки покоя по первому приближению. Вид приближения:

$$
  \frac{dx}{dt} = P(x,y) \approx \frac{\partial P(x_{0}, y_{0})}{\partial x} \cdot (x - x_{0}) + \frac{\partial P(x_{0}, y_{0})}{\partial y} \cdot (y - y_{0})
$$

$$
  \frac{dy}{dt} = Q(x,y) \approx \frac{\partial Q(x_{0}, y_{0})}{\partial x} \cdot (x - x_{0}) + \frac{\partial Q(x_{0}, y_{0})}{\partial y} \cdot (y - y_{0}),
$$
где $P(x, y)$ и $Q(x, y)$ - система функций дифференциальной системы, пара $(x_{0}, y_{0})$ - точка покоя системы дифференциальных уравнений или точка установленного стационарного режима для ассимптотически устойчивых и просто устойчивых систем дифференциальных уравнений.

**Нахождение точки покоя системы дифференциальных уравнений.** Поставим в систему уравнений в левые части нули, обозначающие ноль приращений функций $x(t)$ и $y(t)$ или точку стационарного режима динамической системы:

$$
  0 = x_{0} \cdot \left(\beta_{1} - \alpha_{1} \cdot y_{0} \right)
$$

$$
  0 = y_{0} \cdot \left(\beta_{2} - \alpha_{2} \cdot x_{0} \right).
$$

Тогда решением данной системы $(x_{0}, y_{0})$ будет являться следующая пара значений:

$$
  x_{0} = \frac{\beta_{2}}{\alpha_{2}} 
$$

$$
  y_{0} = \frac{\beta_{1}}{\alpha_{1}} .
$$
Подставим данную пару значений в уравнения системы по первому приближению, получим:

$$
  \frac{dx}{dt} \approx \left(\beta_{1} - \alpha_{1} \cdot y_{0} \right) \cdot (x - x_{0}) - \alpha_{1} \cdot x_{0} \cdot (y - y_{0})
$$

$$
  \frac{dy}{dt} 
  \approx - \alpha_{2} \cdot y_{0} \cdot (x - x_{0}) + \left(\beta_{2} - \alpha_{2} \cdot x_{0} \right) \cdot (y - y_{0})
$$

Тогда в первом приближении система уравнений будет выглядеть следующим образом:

$$
  \frac{dx}{dt} \approx \frac{\beta_{1} \cdot \beta_{2}}{\alpha_{2}} - \alpha_{1} \cdot \frac{\beta_{2}}{\alpha_{2}} \cdot y 
$$

$$
  \frac{dy}{dt} 
  \approx \frac{\beta_{1} \cdot \beta_{2}}{\alpha_{1}} - \alpha_{2} \cdot \frac{\beta_{1}}{\alpha_{1}} \cdot x.
$$
Запишем матрицу $A$ системы уравнений в смещениях $\left( \frac{dX}{dt}, \frac{dY}{dt} \right)$ относительно точки $(0, 0)$, а также определитель данной матрицы:

$$
 A = \begin{pmatrix}
0 &  - \alpha_{1} \cdot \frac{\beta_{2}}{\alpha_{2}}\\
- \alpha_{2} \cdot \frac{\beta_{1}}{\alpha_{1}} & 0
\end{pmatrix}
$$
$$
 det(A) = - (- \alpha_{1} \cdot \frac{\beta_{2}}{\alpha_{2}}) \cdot (- \alpha_{2} \cdot \frac{\beta_{1}}{\alpha_{1}}) = -\beta_{1} \beta_{2}.
$$ 

**Характеристическое уравнение системы первого приближения.** Для системы дифференциальных уравнений в первом приближении запишем характеристическое уравнение для определения характеров возможных точек покоя системы в зависимости от значений параметров системы. Характеристическое уравнение выглядит следующим образом:

$$
  \left| A - \lambda \cdot I  \right| = 0, 
$$

где $A$ - матрица системы уравнений, $\lambda$ - собственные значения матрицы $A$, $I$ - единичная матрица.

Найдем $\lambda$ из данного уравнения:

$$
 \left| A - \lambda \cdot I  \right| = \begin{vmatrix}
-\lambda &  - \alpha_{1} \cdot \frac{\beta_{2}}{\alpha_{2}}\\
- \alpha_{2} \cdot \frac{\beta_{1}}{\alpha_{1}} & -\lambda
\end{vmatrix} = 0
$$

$$
  \lambda^{2} -\beta_{1} \beta_{2} = 0
$$

$$
\lambda_{1, 2} = \pm \sqrt{\beta_{1} \cdot \beta_{2}}.
$$


Из представленного равенства закономерно получаем, что: 

  1. $\lambda_{1, 2} \in \mathbb{R}$ в случае если $(\beta_{1} > 0 \cap \beta_{2} > 0) \cup (\beta_{1} < 0 \cap \beta_{2} < 0)$
  2. $\lambda_{1, 2} \in \mathbb{С}$, если $(\beta_{1} > 0 \cap \beta_{2} < 0) \cup (\beta_{1} < 0 \cap \beta_{2} > 0)$.

В случае, если $\lambda_{1, 2} \in \mathbb{R}$, то $\lambda_{1} > 0$ и $\lambda_{2} < 0$ - точка $(x_0, y_0)$ - седлоузел на графике фазовой плоскости.

В случае, если $\lambda_{1, 2} \in \mathbb{С}$, то $\lambda_{1, 2} = \pm i \cdot \sqrt{ \left| \beta_{1} \right| \cdot \left| \beta_{2} \right|}$ - точка $(x_0, y_0)$ - центр на графике фазовой плоскости.

<!-- ## Моделирование системы дифференциальных уравнений -->

<!-- ```{r, echo = F} -->
<!-- LV <- function(time, x, parms) { -->
<!--   with(as.list(c(parms, x)), { -->

<!--   dx1 <- x1 * (parms[1] - parms[2] * x2) -->
<!--   dx2 <- x2 * (parms[3] - parms[4] * x1) -->

<!--   return(list(c(dx1, dx2))) -->
<!--   }) -->
<!-- } -->


<!-- parameters <- c(b1 = -0.005, a1 = -0.0005, b2 = -0.0025, a2 = 0.0007) -->
<!-- ini_state <- c(x1 = -30.1, x2 = -0.4) -->
<!-- times <- seq(0, 1000, 1) -->

<!-- out <- ode(func = LV, y = ini_state, parms = parameters, times = times) -->

<!-- parameters2 <- c(b1 = -0.005, a1 = -0.0005, b2 = -0.0025, a2 = 0.0007) -->
<!-- ini_state2 <- c(x1 = -30.1, x2 = -0.9) -->
<!-- times2 <- seq(0, 1000, 1) -->
<!-- out2 <- ode(func = LV, y = ini_state2, parms = parameters2, times = times2) -->

<!-- parameters3 <- c(b1 = -0.005, a1 = -0.0005, b2 = -0.0025, a2 = 0.0007) -->
<!-- ini_state3 <- c(x1 = -30.1, x2 = -1.4) -->
<!-- times3 <- seq(0, 1000, 1) -->
<!-- out3 <- ode(func = LV, y = ini_state3, parms = parameters3, times = times3) -->

<!-- parameters4 <- c(b1 = -0.005, a1 = -0.0005, b2 = -0.0025, a2 = 0.0007) -->
<!-- ini_state4 <- c(x1 = -30.1, x2 = -1.9) -->
<!-- times4 <- seq(0, 1000, 1) -->

<!-- out4 <- ode(func = LV, y = ini_state4, parms = parameters4, times = times4) -->

<!-- parameters5 <- c(b1 = -0.005, a1 = -0.0005, b2 = -0.0025, a2 = 0.0007) -->
<!-- ini_state5 <- c(x1 = -30.1, x2 = -2.4) -->
<!-- times5 <- seq(0, 1000, 1) -->
<!-- out5 <- ode(func = LV, y = ini_state5, parms = parameters5, times = times5) -->

<!-- parameters6 <- c(b1 = -0.005, a1 = -0.0005, b2 = -0.0025, a2 = 0.0007) -->
<!-- ini_state6 <- c(x1 = -30.1, x2 = -2.9) -->
<!-- times6 <- seq(0, 1000, 1) -->
<!-- out6 <- ode(func = LV, y = ini_state6, parms = parameters6, times = times6) -->
<!-- ``` -->

<!-- ```{r, echo = F, dpi = 1024} -->
<!-- plot(out[, 2], out[, 3], type = "l", ylim = c(-15, 0), -->
<!--      main = "Седловая точка процесса", -->
<!--      ylab = "y", -->
<!--      xlab = "x") -->
<!-- lines(out2[, 2], out2[, 3]) -->
<!-- lines(out3[, 2], out3[, 3]) -->
<!-- lines(out4[, 2], out4[, 3]) -->
<!-- lines(out5[, 2], out5[, 3]) -->
<!-- lines(out6[, 2], out6[, 3]) -->
<!-- points(x = c(ini_state[1], ini_state2[1], ini_state3[1], ini_state4[1], ini_state5[1], ini_state6[1]), -->
<!--        y = c(ini_state[2], ini_state2[2], ini_state3[2], ini_state4[2], ini_state5[2], ini_state6[2]), col = "red") -->
<!-- abline(h = seq(1, -31, -1), col = "grey", lty = 2) -->
<!-- abline(v = seq(1, -31, -1), col = "grey", lty = 2) -->
<!-- ``` -->

<!-- ```{r, echo = F} -->
<!-- LV <- function(time, x, parms) { -->
<!--   with(as.list(c(parms, x)), { -->

<!--   dx1 <- x1 * (parms[1] - parms[2] * x2) -->
<!--   dx2 <- x2 * (parms[3] - parms[4] * x1) -->

<!--   return(list(c(dx1, dx2))) -->
<!--   }) -->
<!-- } -->


<!-- parameters <- c(b1 = 0.05, a1 = -0.0005, b2 = 0.025, a2 = 0.0007) -->
<!-- ini_state <- c(x1 = -30.1, x2 = -0.4) -->
<!-- times <- seq(0, 1000, 1) -->
<!-- out <- ode(func = LV, y = ini_state, parms = parameters, times = times) -->

<!-- ini_state2 <- c(x1 = -30.1, x2 = -0.9) -->
<!-- out2 <- ode(func = LV, y = ini_state2, parms = parameters, times = times) -->

<!-- ini_state3 <- c(x1 = -30.1, x2 = -1.4) -->
<!-- out3 <- ode(func = LV, y = ini_state3, parms = parameters, times = times) -->

<!-- ini_state4 <- c(x1 = -30.1, x2 = -1.9) -->
<!-- out4 <- ode(func = LV, y = ini_state4, parms = parameters, times = times) -->

<!-- ini_state5 <- c(x1 = -30.1, x2 = -2.4) -->
<!-- out5 <- ode(func = LV, y = ini_state5, parms = parameters, times = times) -->

<!-- ini_state6 <- c(x1 = -30.1, x2 = -2.9) -->
<!-- out6 <- ode(func = LV, y = ini_state6, parms = parameters, times = times) -->
<!-- ``` -->

<!-- ```{r, echo = F, dpi = 1024} -->
<!-- plot(out[, 2], out[, 3], type = "l", ylim = c(-1050, 0), -->
<!--      main = "Седловая точка процесса", -->
<!--      ylab = "y", -->
<!--      xlab = "x") -->
<!-- lines(out2[, 2], out2[, 3]) -->
<!-- lines(out3[, 2], out3[, 3]) -->
<!-- lines(out4[, 2], out4[, 3]) -->
<!-- lines(out5[, 2], out5[, 3]) -->
<!-- lines(out6[, 2], out6[, 3]) -->
<!-- points(x = c(ini_state[1], ini_state2[1], ini_state3[1], ini_state4[1], ini_state5[1], ini_state6[1]), -->
<!--        y = c(ini_state[2], ini_state2[2], ini_state3[2], ini_state4[2], ini_state5[2], ini_state6[2]), col = "red") -->
<!-- abline(h = seq(-1100, 100, 50), col = "grey", lty = 2) -->
<!-- abline(v = seq(-300, 100, 20), col = "grey", lty = 2) -->
<!-- ``` -->


<!-- ```{r, echo = F} -->
<!-- LV <- function(time, x, parms) { -->
<!--   with(as.list(c(parms, x)), { -->

<!--   dx1 <- x1 * (parms[1] - parms[2] * x2) -->
<!--   dx2 <- x2 * (parms[3] - parms[4] * x1) -->

<!--   return(list(c(dx1, dx2))) -->
<!--   }) -->
<!-- } -->


<!-- parameters <- c(b1 = -1.5, a1 = -0.05, b2 = 2.5, a2 = 0.07) -->
<!-- ini_state <- c(x1 = -1.1, x2 = -1.4) -->
<!-- times <- seq(0, 200, 0.1) -->
<!-- out <- ode(func = LV, y = ini_state, parms = parameters, times = times) -->

<!-- ini_state2 <- c(x1 = 1.1, x2 = 1.4) -->
<!-- out2 <- ode(func = LV, y = ini_state2, parms = parameters, times = times) -->

<!-- ini_state3 <- c(x1 = 1.1, x2 = 2.4) -->
<!-- out3 <- ode(func = LV, y = ini_state3, parms = parameters, times = times) -->

<!-- ini_state4 <- c(x1 = 1.1, x2 = -1.4) -->
<!-- out4 <- ode(func = LV, y = ini_state4, parms = parameters, times = times) -->

<!-- ini_state5 <- c(x1 = 1.1, x2 = -2.4) -->
<!-- out5 <- ode(func = LV, y = ini_state5, parms = parameters, times = times) -->

<!-- ini_state6 <- c(x1 = -1.1, x2 = -1.9) -->
<!-- out6 <- ode(func = LV, y = ini_state6, parms = parameters, times = times) -->
<!-- ``` -->

<!-- ```{r, echo = F, dpi = 1024} -->
<!-- plot(out[, 2], out[, 3], type = "l", -->
<!--      ylim = c(-50, 250), -->
<!--      xlim = c(-1, 10), -->
<!--      main = "Седловая точка процесса", -->
<!--      ylab = "y", -->
<!--      xlab = "x") -->
<!-- lines(out2[, 2], out2[, 3]) -->
<!-- lines(out3[, 2], out3[, 3]) -->
<!-- lines(out4[, 2], out4[, 3]) -->
<!-- lines(out5[, 2], out5[, 3]) -->
<!-- lines(out6[, 2], out6[, 3]) -->
<!-- points(x = c(ini_state[1], ini_state2[1], ini_state3[1], ini_state4[1], ini_state5[1], ini_state6[1]), -->
<!--        y = c(ini_state[2], ini_state2[2], ini_state3[2], ini_state4[2], ini_state5[2], ini_state6[2]), col = "red") -->
<!-- abline(h = seq(-1100, 1100, 50), col = "grey", lty = 2) -->
<!-- abline(v = seq(-1000, 1000, 0.25), col = "grey", lty = 2) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- parameters <- c(b1 = -1.5, a1 = -0.05, b2 = 2.5, a2 = 0.07) -->
<!-- ini_state <- c(x1 = -1.1, x2 = -1.4) -->
<!-- times <- seq(0, 200, 0.1) -->
<!-- out <- ode(func = LV, y = ini_state, parms = parameters, times = times) -->

<!-- ini_state2 <- c(x1 = 1.1, x2 = 1.4) -->
<!-- out2 <- ode(func = LV, y = ini_state2, parms = parameters, times = times) -->

<!-- ini_state3 <- c(x1 = 1.1, x2 = 2.4) -->
<!-- out3 <- ode(func = LV, y = ini_state3, parms = parameters, times = times) -->

<!-- ini_state4 <- c(x1 = 1.1, x2 = -1.4) -->
<!-- out4 <- ode(func = LV, y = ini_state4, parms = parameters, times = times) -->

<!-- ini_state5 <- c(x1 = 1.1, x2 = -2.4) -->
<!-- out5 <- ode(func = LV, y = ini_state5, parms = parameters, times = times) -->

<!-- ini_state6 <- c(x1 = -1.1, x2 = -1.9) -->
<!-- out6 <- ode(func = LV, y = ini_state6, parms = parameters, times = times) -->

<!-- plot(out[, 2], out[, 3], type = "l", -->
<!--      ylim = c(-50, 250), -->
<!--      xlim = c(-1, 10), -->
<!--      main = "Седловая точка процесса", -->
<!--      ylab = "y", -->
<!--      xlab = "x") -->
<!-- lines(out2[, 2], out2[, 3]) -->
<!-- lines(out3[, 2], out3[, 3]) -->
<!-- lines(out4[, 2], out4[, 3]) -->
<!-- lines(out5[, 2], out5[, 3]) -->
<!-- lines(out6[, 2], out6[, 3]) -->
<!-- points(x = c(ini_state[1], ini_state2[1], ini_state3[1], ini_state4[1], ini_state5[1], ini_state6[1]), -->
<!--        y = c(ini_state[2], ini_state2[2], ini_state3[2], ini_state4[2], ini_state5[2], ini_state6[2]), col = "red") -->
<!-- abline(h = seq(-1100, 1100, 50), col = "grey", lty = 2) -->
<!-- abline(v = seq(-1000, 1000, 0.25), col = "grey", lty = 2) -->
<!-- ``` -->


## Определение параметров дифференциальной модели

Тогда, система анаморфоз для определения параметров данной системы взаимодействия выглядит следующим образом:

$$
  \frac{dx}{x \cdot dt} = \beta_{1} - \alpha_{1} \cdot y
$$

$$
  \frac{dy}{y \cdot dt} = \beta_{2} - \alpha_{2} \cdot x
$$

Алгоритм определения данных параметров выглядит следующим образом: 

  1. построить в спрямляющих функциональных координатах исходные зависимости,
  2. оценить параметры линейных участков данных процессов в спрямляющих координатах,
  3. сохранить параметры линейных моделей.


## Поиск модели системы дифференциального уравнения

На графиках парного развития процесса заболеваемости в двух странах были отображены графики динамики в полулогарифмах. Тогда в исходном уравнении динамика представлена в следующем виде:

$$
  \frac{dx(t_i)}{dt} = ln\left( Egypt_i \right)
$$

$$
  \frac{dy(t_i)}{dt} = ln\left( Belarus_i \right)
$$

А функции в уравнениях это уровень заболеваемости в полулогарифмах с накоплением на каждый день

$$
  x(t = n) = \sum_{i = 1}^{n} ln(Egypt_i)
$$

$$
  y(t = n) = \sum_{i = 1}^{n} ln(Belarus_i)
$$



Построим графики в спрямляющих координатах для поиска параметров модели взаимодействия двух процессов на основе модели линейной регрессии относительно участков спрямления модели:


```{r Egypt_Belarus, echo = F, out.height=800, out.width=800, dpi = 512}
df1 <- select(df_confirmed, contains("Egypt"))[-(1:70), ]
df2 <- select(df_confirmed, contains("Belarus"))[-(1:70), ]
```


```{r, dpi = 512, echo =F}
plot(x = cumsum(c(0, log(diff(time_series_Belarus) + 1))),
     y = c(0, log(diff(time_series_Egypt) + 1)) / cumsum(c(0, log(diff(time_series_Egypt) + 1))),
     ylim = c(0, 0.02),
     xlim = c(250, 2800),
     xlab = "Belarus",
     ylab = "dEgypt_dt / Egypt",
     main = "X накопленные значения", 
     pch = 19, 
     cex = I(0.5))

alpha_X_red <- -0.000028
beta_X_red <- 0.028
abline(a = beta_X_red, b = alpha_X_red, col = "red")
text(x = 800, y = 0.015, label = paste("alpha_red =", alpha_X_red))
text(x = 800, y = 0.014, label = paste("beta_red =", beta_X_red))


alpha_X_blue <- -0.000001
beta_X_blue <- 0.0053
abline(a = beta_X_blue, b = alpha_X_blue, col = "blue")
text(x = 1500, y = 0.0055, label = paste("alpha_blue =", alpha_X_blue))
text(x = 1500, y = 0.0049, label = paste("beta_blue =", beta_X_blue))
```


```{r, dpi = 512, echo =F}
plot(x = cumsum(c(0, log(diff(time_series_Egypt) + 1))),
     y = c(0, log(diff(time_series_Belarus) + 1)) / cumsum(c(0, log(diff(time_series_Belarus) + 1))),
     ylim = c(0, 0.02),
     xlim = c(250, 2800),
     xlab = "Egypt",
     ylab = "dBelarus_dt / Belarus",
     main = "Y накопленные значения", 
     pch = 19, 
     cex = I(0.5))

alpha_Y_red <- -0.000028
beta_Y_red <- 0.028
abline(a = beta_Y_red, b = alpha_Y_red, col = "red")
text(x = 800, y = 0.015, label = paste("alpha_red =", alpha_Y_red))
text(x = 800, y = 0.014, label = paste("beta_red =", beta_Y_red))


alpha_Y_blue <- -0.000001
beta_Y_blue <- 0.0053
abline(a = beta_Y_blue, b = alpha_Y_blue, col = "blue")
text(x = 2300, y = 0.0055, label = paste("alpha_blue =", alpha_Y_blue))
text(x = 2300, y = 0.0049, label = paste("beta_blue =", beta_Y_blue))

alpha_Y_green <- -0.0000028
beta_Y_green <- 0.0091
abline(a = beta_Y_green, b = alpha_Y_green, col = "green")
text(x = 1500, y = 0.0075, label = paste("alpha_green =", alpha_Y_green))
text(x = 1500, y = 0.0069, label = paste("beta_green =", beta_Y_green))
```

 
**Модель "красной" линии**

$$
  \frac{dx}{x \cdot dt} = 0.028 + 2.8 * 10^{-5} \cdot y
$$

$$
  \frac{dy}{y \cdot dt} = 0.028 + 2.8 * 10^{-5} \cdot x
$$

**Модель "синей" линии**

$$
  \frac{dx}{x \cdot dt} = 0.0053 + 10^{-6} \cdot y
$$

$$
  \frac{dy}{y \cdot dt} = 0.0053 + 10^{-6} \cdot x
$$

**Модель "сине-зелёной" линии**

$$
  \frac{dx}{x \cdot dt} = 0.0053 + 10^{-6} \cdot y
$$

$$
  \frac{dy}{y \cdot dt} = 0.0091 + 2.8 \cdot 10^{-6} \cdot x
$$

**Модель "красно-зелёной" линии**

$$
  \frac{dx}{x \cdot dt} = 0.028 + 2.8 \cdot 10^{-5} \cdot y
$$

$$
  \frac{dy}{y \cdot dt} = 0.0091 + 2.8 \cdot 10^{-6} \cdot x
$$

В качестве главной модели выберем последнюю (**Модель "красно-зелёной" линии**), по причине того, что она занимает большую часть зависимости. Получим для данной модели системы уравнений качественные кривые и фазовую плоскость. В качестве динамики X и Y выберем исходные данные накопленной заболеваемости в полулогарифмическом масштабе. Полученные оценки модели могут быть применены также к любым другим модельным данным.

```{r, echo=FALSE}
S_x = cumsum(c(0, log(diff(time_series_Egypt) + 1)))
S_y = cumsum(c(0, log(diff(time_series_Belarus) + 1)))

S_x_dx <- S_x * (beta_X_blue - alpha_X_blue * S_y)
S_y_dy <- S_y * (beta_Y_green - alpha_Y_green * S_x)
```

```{r, out.height=1000, out.width=1000, dpi = 1024, echo = F}
plot(diff(S_y_dy), col = "red", type = "o", cex = I(0.5), pch = 19, lwd = I(0.5),
     xlab = "Дни с 2020-01-22",
     ylab = "Модельные относительные величины заболеваемости",
     main = "График модельных кривых в реузльтате получения параметров")
lines(diff(S_x_dx), col = "blue", type = "o", cex = I(0.5), pch = 19, lwd = I(0.5))
abline(v = seq(0, 600, 10), lty = 2, col = "grey")
abline(h = seq(0, 1, 0.01), lty = 2, col = "grey")
legend(x = 0, y = 0.17, legend = c("Модель Беларусь", "Модель Египет"),
       lty = c(1, 1), pch = 19, col = c("red", "blue"))
```

Построим график фазовой плоскости модельных кривых.

```{r, out.height=1000, out.width=1000, dpi = 1024, echo = F}
plot(x = diff(S_x_dx), y = diff(S_y_dy), 
     type = "p", pch = 19, 
     cex = I(0.7), col = "blue3",
     main = "Оценка сепаратрис седловой точки фазовой плоскости",
     ylab = "Belarus модельная заболеваемость",
     xlab = "Egypt модельная заболеваемость")
abline(a = 0.025, b = 2, col = "red", lty = 2)
abline(a = 0.055, b = 0.4, col = "red", lty = 2)
```

На графике фазовой плоскости модельных кривых чётко видно, что оценённые прямые линии являются хорошей оценкой корреляционной зависимости модельных показателей. В центре фазовой плоскости присутствует "петля" интерпретировать которую не удаётся с точки зрения дифференциальной модели данного класса.

Ниже покажем скорректированные динамики при помощи нормирования и регрессии на исходную динамику для сравнения полученных моделей с релаьными данными.

```{r, echo = F, dpi = 1024}
df_model <- data.frame(Y = diff(S_x_dx), X = (1:length(diff(S_x_dx))))
model_lm_sx <- lm(Y ~ X, data = df_model)

df_real <- data.frame(Y = log(diff(time_series_Egypt) + 1), 
                      X = (1:length(diff(time_series_Egypt) + 1)))
model_Egypt <- lm(Y ~ X, data = df_real)

plot(((diff(S_x_dx) - model_lm_sx$coefficients[1] - 1:length(diff(S_x_dx)) * model_lm_sx$coefficients[2]) * (165) + 
        model_Egypt$coefficients[1] + model_Egypt$coefficients[2] * (1:length(diff(time_series_Egypt)))), 
     col = "blue", type =  "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Сравнение моделируемой динамики процесса и исходной",
     ylab = "Полулогарифм динамики процесса",
     xlab = paste("Дни с", df_confirmed$date[1]))
lines(log(diff(time_series_Egypt)), 
      col = "red", lwd = I(0.5), type = "o", pch = 19, cex = I(0.5))
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Egypt) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
abline(v = maxes_Egypt, col = "orange2")
legend(x = 300, y = 2,
       legend = c("LN приросты Египет", "LN приросты модель"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))

```




```{r, echo = F, dpi = 1024}
df_model2 <- data.frame(Y = diff(S_y_dy), X = (1:length(diff(S_y_dy))))
model_lm_sy <- lm(Y ~ X, data = df_model2)

df_real2 <- data.frame(Y = log(diff(time_series_Belarus) + 1), 
                      X = (1:length(diff(time_series_Belarus) + 1)))
model_Bel <- lm(Y ~ X, data = df_real2)

plot(((diff(S_y_dy) - model_lm_sy$coefficients[1] - 1:length(diff(S_y_dy)) * model_lm_sy$coefficients[2]) * (105) + 
        model_Bel$coefficients[1] + model_Bel$coefficients[2] * (1:length(diff(time_series_Belarus)))), 
     col = "blue", type =  "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Сравнение моделируемой динамики процесса и исходной",
     ylab = "Полулогарифм динамики процесса",
     xlab = paste("Дни с", df_confirmed$date[1]),
     ylim = c(2, 8.5))
lines(log(diff(time_series_Belarus)), 
      col = "red", lwd = I(0.5), type = "o", pch = 19, cex = I(0.5))
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Belarus) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
abline(v = maxes_Egypt - tau, col = "orange2")
legend(x = 300, y = 4,
       legend = c("LN приросты Беларусь", "LN приросты модель"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
```

На графиках сравнения реальных данных и модельных кривых заметим ощутимое парное влияние одних значений на другие в результате которых на графике динамики в Египте мы видим небольшие флуктуации, перешедшие к данной модели от динамики в Беларуси. Данный эффект происходит из-за навязанного взаимодействия данных двух показателей.

Применим найденные коэффициенты модели к тому же виду системы, но в качестве реальных данных подставим вместо данных заболеваемости в Беларуси, данные заболеваемости в России. Найденные коэффициенты из анаморфоз дифференциальной системы по динамике Беларуси и Египта проверим на возможность применения к другим данным схожей природы. Если данные коэффициенты позволят воспроизвести предыдущий результат моделирования динамической системы, то можно констатировать факт, что выбранная система дифференциальных уравнений действительно является дифференциальной моделью парного развития процесса заболеваемости в странах мира.

```{r, echo = F, dpi = 1024}
df1 <- select(df_confirmed, contains("Egypt"))[, ]
df2 <- select(df_confirmed, contains("Russia"))[, ]
```


```{r, echo = F, dpi = 1024}
S_x = cumsum(c(0, log(diff(df1) + 1)))
S_y = cumsum(c(0, log(diff(df2) + 1)))

S_x_dx <- S_x * (beta_X_blue - alpha_X_blue * S_y)
S_y_dy <- S_y * (beta_Y_green - alpha_Y_green * S_x)
```


```{r, echo = F, dpi = 1024}
plot(diff(S_y_dy), col = "red", type = "o", cex = I(0.5), pch = 19, lwd = I(0.5),
     main = "Парная динамика полученных модельных кривых Россиия и Египет",
     xlab = "Дни с 2020-01-22")
lines(diff(S_x_dx), col = "blue", type = "o", cex = I(0.5), pch = 19, lwd = I(0.5))
legend(x = -5, y = 0.22, legend = c("в России", "в Египте"),
       col = c("red", "blue"), lty = c(1, 1), pch = 19)
```

Изобразим на графике фазовую плоскость полученных модельных кривых для анализа фазового портрета двух динамических показателей.

```{r, echo = F, dpi = 1024}
plot(x = diff(S_x_dx), y = diff(S_y_dy), 
     type = "p", pch = 19, 
     cex = I(0.7), col = "blue3",
     main = "Оценка сепаратрис седловой точки фазовой плоскости",
     ylab = "Russia модельная заболеваемость",
     xlab = "Egypt модельная заболеваемость")
abline(a = 0.055, b = 2.1, col = "red", lty = 2)
abline(a = 0.09, b = 0.4, col = "red", lty = 2)
```

На фазовом портрете видна точка перехода зависимости в следующее структурное состояние, на прошлом фазовом портрете в данном месте была "петля". Прямые линии, показанные на рисунке имеют те же самые углы наклона, но смещенный центр пересечения за счёт смещения их по оси ординат вверх.

Изобразим полученные модельные данные динамики в сравнении с реальными данными, на которых моделировались полученные кривые. Отметим на графике с Египтом большую схожесть реальных и модельных данных несмотря на навязанное системной взаимодействие с другим показателем динамики численности популяции больных. Это объясняется наличием собственного коэффициента, полученного из линеаризованной зависимости $\frac{dEgypt}{Egypt \cdot dt} \sim Belarus$ в начале исследования парной динамики.

```{r, echo = F, dpi = 1024}
df_model <- data.frame(Y = diff(S_x_dx), X = (1:length(diff(S_x_dx))))
model_lm_sx <- lm(Y ~ X, data = df_model)

df_real <- data.frame(Y = log(diff(time_series_Egypt) + 1), 
                      X = (1:length(diff(time_series_Egypt) + 1)))
model_Egypt <- lm(Y ~ X, data = df_real)

plot(((diff(S_x_dx) - model_lm_sx$coefficients[1] - 1:length(diff(S_x_dx)) * model_lm_sx$coefficients[2]) * (165) + 
        model_Egypt$coefficients[1] + model_Egypt$coefficients[2] * (1:length(diff(time_series_Egypt)))), 
     col = "blue", type =  "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Сравнение моделируемой динамики процесса и исходной",
     ylab = "Полулогарифм динамики процесса",
     xlab = paste("Дни с", df_confirmed$date[1]))
lines(log(diff(time_series_Egypt)), 
      col = "red", lwd = I(0.5), type = "o", pch = 19, cex = I(0.5))
abline(h = seq(0, 9, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, length(time_series_Egypt) + 10, 25), lwd = I(0.5), lty = 2, col = "grey")
abline(v = maxes_Egypt, col = "orange2")
legend(x = 300, y = 2,
       legend = c("LN приросты Египет", "LN приросты модель"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
```

Графически изобразим наложение полученной модельной динамики системы и реальных данных для России. Напомним, что коэффициенты модели были взяты из анализа парной динамики Египта с Беларусью.

```{r, echo = F, dpi = 1024}
df_model2 <- data.frame(Y = diff(S_y_dy), X = (1:length(diff(S_y_dy))))
model_lm_sy <- lm(Y ~ X, data = df_model2)

df_real2 <- data.frame(Y = log(diff(df2) + 1), 
                      X = (1:length(diff(df2) + 1)))
model_Bel <- lm(Y ~ X, data = df_real2)

plot(((diff(S_y_dy) - model_lm_sy$coefficients[1] - 1:length(diff(S_y_dy)) * model_lm_sy$coefficients[2]) * (110) + 
        model_Bel$coefficients[1] + model_Bel$coefficients[2] * (1:length(diff(df2)))), 
     col = "blue", type =  "o", cex = I(0.5), lwd = I(0.5), pch = 19,
     main = "Сравнение моделируемой динамики процесса и исходной",
     ylab = "Полулогарифм динамики процесса",
     xlab = paste("Дни с", df_confirmed$date[1]),
     ylim = c(6, 11))
lines(log(diff(df2)), 
      col = "red", lwd = I(0.5), type = "o", pch = 19, cex = I(0.5))
abline(h = seq(0, 12, 0.5), lwd = I(0.5), lty = 2, col = "grey")
abline(v = seq(0, 600, 50), lwd = I(0.5), lty = 2, col = "grey")
legend(x = 300, y = 7,
       legend = c("LN приросты Россия", "LN приросты модель"),
       col = c("red", "blue"), lty = c(1, 1), pch = c(19, 19))
```

Показанная на графике динамика частично совпадает с реальными данными. Проявляются признаки взаимодействия в виде резких пиков от данных по заражениям в Египте, что является логичным ввиду навязанной нами системной связке данных временных рядов.

## Выводы

При исследование динамики двух стран в паре при возможности постановки их взаимодействия было показан неоспоримый факт наличия на определённых участках данных модельного взаимодействия в соответствии с системой дифференциальных уравнений взаимодействия двух функций с логистической поправкой. Как было выяснено при анализе динамики развития заболевания Covid19 в России, данная система относится к классу динамических систем с ограничением сверху на рост численности показателя популяции заражённых. Данный факт подтверждает возможность проявления взаимодействия систем также с ограничением на их рост.

При анализе данных в спрямляющих координатах дифференциальной системы было показано наличие большого числа продожительных прямых участков, что показывает явное наличие в данных соответствующих модельных участков.

Попытка моделирования парного взаимодействия тех же величин на основе полученных модельных коэффициентов подтверждает также полученную системную связь между показателями динамики двух стран, находящихся в туристических отношениях. Такого рода взаимодействия с запаздыванием являются классическими для целого ряда динамических систем, и также проявляются и при рассмотрении парной динамики заболеваемости Covid19.

# Список литературы

  1.  Charles Therrien, Murali Tummala. Probability and Random Processes for Electrical and Computer Engineers. — CRC Press, 2012. — P. 287
  2. Verhulst, P. F., (1838). Notice sur la loi que la population poursuit dans son accroissement. Correspondance mathématique et physique, 10, 113—121.
  3. Verhulst, P. F., Recherches Mathématiques sur La Loi D’Accroissement de la Population, Nouveaux Mémoires de l’Académie Royale des Sciences et Belles-Lettres de Bruxelles, 18, Art. 1, 1—45, 1845 (Mathematical Researches into the Law of Population Growth Increase).
  4. Pearl, Raymond. The Biology of Population Growth (англ.) // The American Mercury. — 1924. — Ноябрь (т. III, № 11). — С. 293– 305.
  5. Pearl, Raymond and Lowell J. Reed. On the Rate of Growth of the Population of the United States since 1790 and its Mathematical Representation (англ.) // Proceedings of the National Academy of Sciences of the United States of America (PNAS; USA). — 1920. — 15 июня (т. 6, № 6). — С. 275–288.
  6. Gompertz, B. "On the Nature of the Function Expressive of the Law of Human Mortality, and on a New Mode of Determining the Value of Life Contingencies." Phil. Trans. Roy. Soc. London 123, 513-585, 1832.
  7. Hofbauer, Josef; Sigmund, Karl (1998). "Dynamical Systems and Lotka–Volterra Equations". Evolutionary Games and Population Dynamics. New York: Cambridge University Press. pp. 1–54. ISBN 0-521-62570-X.
  8. Кузьмин В.И., Гадзаов А.Ф. Методы построения моделей по эмпирическим данным: Учебное пособие / Московский государственный институт радиотехники, электроники и автоматики (технический университет) – М., 2012. – 94 с.
  9. Кузьмин В.И., Гадзаов А.Ф. Прикладные задачи математической статистики: Учебное пособие / Московский государственный институт радиотехники, электроники и автоматики (технический университет) – М., 2011. – 92 с.
  10. Модели и методы определения параметров нелинейных процессов [Электронный ресурс]: монография / В. И. Кузьмин [и др.]. — М.: МИРЭА, 2016. — 148 с.. — Электрон. опт. диск (ISO) ISBN 978-5-600-01609-5
  11. Модели и алгоритмы анализа нелинейных колебаний с трендом [Электронный ресурс]: монография / В. И. Кузьмин [и др.]. — М.: МИРЭА, 2015. — 94 с.. — Электрон. опт. диск (ISO) ISBN 978-5-7339-1109-9
  12. Методы анализа данных [Электронный ресурс]: учебное пособие / В. И. Кузьмин, А. Ф. Гадзаов. — М.: РТУ МИРЭА, 2020. — Электрон. опт. диск (ISO)

